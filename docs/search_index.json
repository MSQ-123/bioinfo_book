[["backend-methods.html", "Chapter 4 Backend methods 4.1 MySQL query 4.2 SpringBoot in java 4.3 Merge, annotation algorithm writen in java 4.4 Some tricks", " Chapter 4 Backend methods We describe our backend methods step by step in this chapter. We decided to use java platform as the middle-ware, which integrates SQL query, api testing and json data generation (api exposed to front-end). 4.1 MySQL query The covid_annot table behind my shiny web is uploaded to MySQL database, total 16 columns (see below). Consider that CovidShiny mainly focuses on querying data from the backend, the first thing to improve users experience and start our project is putting the large dataset in csv format in db (previously it was loaded into memory, which is unapplicable to production-grade app). Note: The dataset uploaded should be checked seriously just in case (some missing rows and NA in not-null column). Due to the high frequency of update, incremental id (corresponding to each unique mutation record of virus) column was set. Next, I have to mention that the subset function used in my shiny framework can be pretty low-efficient when dealing large dataframe with up to hundreds of thousands rows (since R have to scanning the whole dataframe row by row to find all targets). So the subset syntax should be transformed into SQL query syntax (first in R, for test), for example: From: # this example subset by country,M_type (with top frequency), if(country != &quot;global&quot;){ covid_annot&lt;-covid_annot[covid_annot$country == country, ] covid_annot&lt;- covid_annot[covid_annot$M_type %in% names(head(sort(table(covid_annot$M_type),decreasing=TRUE),n=top)),] } if(country == &quot;global&quot;){ covid_annot&lt;- covid_annot[covid_annot$M_type %in% names(head(sort(table(covid_annot$M_type),decreasing=TRUE),n=top)),] } to: exec_sql_query_21&lt;-function(conn,args_protein_list,args_country_list,order_M_type){ if (args_country_list==&#39;global&#39;){ #global without force index, slow sql_sentence = glue(&quot;select sample, refpos, M_type from covid_annot \\ where M_type in (select M_type from (select M_type from covid_annot \\ where protein = &#39;{args_protein_list}&#39; \\ group by M_type order by count(M_type) DESC LIMIT {order_M_type})as t) \\ and protein = &#39;{args_protein_list}&#39;&quot;) } else{ sql_sentence = glue(&quot;select sample, refpos, M_type from covid_annot FORCE INDEX (country_index)\\ where M_type in (select M_type from (select M_type from covid_annot \\ where protein = &#39;{args_protein_list}&#39; and country = &#39;{args_country_list}&#39;\\ group by M_type order by count(M_type) DESC LIMIT {order_M_type})as t) \\ and protein = &#39;{args_protein_list}&#39; and country = &#39;{args_country_list}&#39;&quot;) } result = dbSendQuery(conn, sql_sentence) # read in result = fetch(result, n = -1) # return dataframe return(result) } result_global_21&lt;-exec_sql_query_21(my_conn,args_protein_list=&#39;S&#39;,args_country_list=&#39;global&#39;,order_M_type=&#39;3&#39;) SQL sentences need to be optimized, in a few aspects: Use count command to summarize the data feature, such as mutations per sample, frequency of each mutation type, etc. We do this because if we always import a large dataset from MySQL to middle-ware to calculate the statistics, it may run into out of memory. Construct index: We used forced index of country field, to faster M_type sorting (i.e., filter country first, then sort M_type). Divide complex SQL sentence into sub-query, intermediate query results can be preserved in middle-ware (java). I made several intermediate files for the test of SQL query. With simple modifications, these SQL sentences can be easily translated into java code. 4.2 SpringBoot in java The web framework is springboot, and we used swagger for api testing (from my perspective, the api testing is the most powerful part of java application, enabling separation of front-end and back-end. Shiny does not have this function). Figure 4.1: Swagger for best APIs The json data returned by api (simulate GET, POST requests): Figure 4.2: APIs return json 4.3 Merge, annotation algorithm writen in java The format of snps records output by nucmer script: Each row represents a single mutation record. However, some mutations are contiguous (e.g, 121:C -&gt; T, 122:A -&gt; C, 123:G -&gt; A). Also, contiguous mutations in some cases can be identified as deletions or insertions. For convenience (also save memory, reduce rows in the dataframe), I merged contiguous mutations into single records, rendering merged nucmer data, making it easy to annotate deletion and insertion events. 4.3.1 Merge records I followed the code written by other publications(Mercatelli and Giorgi 2020). I interpreted this tedious code and expressed the core idea to an algorithm engineer. ### Merge neighboring events ---- samples&lt;-unique(nucmer$qname) length(samples) # 12822 pb&lt;-txtProgressBar(0,length(samples),style=3) for (pbi in 1:length(samples)){ # This will update the nucmer object, deal with each sample records sample&lt;-samples[pbi] allvars&lt;-nucmer[nucmer$qname==sample,] snps&lt;-allvars[(allvars[,&quot;rvar&quot;]!=&quot;.&quot;)&amp;(allvars[,&quot;qvar&quot;]!=&quot;.&quot;),] inss&lt;-allvars[(allvars[,&quot;rvar&quot;]==&quot;.&quot;),] dels&lt;-allvars[(allvars[,&quot;qvar&quot;]==&quot;.&quot;),] # Merge insertions prevqpos&lt;-0 prevrowname&lt;-NULL remove&lt;-c() i&lt;-1 corrector&lt;-0 while(i&lt;=nrow(inss)){ rpos&lt;-inss[i,&quot;rpos&quot;] rvar&lt;-inss[i,&quot;rvar&quot;] qvar&lt;-inss[i,&quot;qvar&quot;] qpos&lt;-inss[i,&quot;qpos&quot;] if((qpos!=1)&amp;(qpos==(prevqpos+1+corrector))){ inss&lt;-inss[-i,] inss[prevrowname,&quot;qvar&quot;]&lt;-paste0(inss[prevrowname,&quot;qvar&quot;],qvar) corrector&lt;-corrector+1 i&lt;-i-1 } else { corrector&lt;-0 prevrowname&lt;-rownames(inss)[i] prevqpos&lt;-qpos } i&lt;-i+1 } # Merge deletions prevqpos&lt;-0 prevrowname&lt;-NULL remove&lt;-c() i&lt;-1 while(i&lt;=nrow(dels)){ rpos&lt;-dels[i,&quot;rpos&quot;] rvar&lt;-dels[i,&quot;rvar&quot;] qvar&lt;-dels[i,&quot;qvar&quot;] qpos&lt;-dels[i,&quot;qpos&quot;] if((qpos!=1)&amp;(qpos==(prevqpos))){ dels&lt;-dels[-i,] dels[prevrowname,&quot;rvar&quot;]&lt;-paste0(dels[prevrowname,&quot;rvar&quot;],rvar) i&lt;-i-1 } else { prevrowname&lt;-rownames(dels)[i] prevqpos&lt;-qpos } i&lt;-i+1 } # Merge SNPs prevqpos&lt;-0 prevrowname&lt;-NULL remove&lt;-c() i&lt;-1 corrector&lt;-0 while(i&lt;=nrow(snps)){ rpos&lt;-snps[i,&quot;rpos&quot;] rvar&lt;-snps[i,&quot;rvar&quot;] qvar&lt;-snps[i,&quot;qvar&quot;] qpos&lt;-snps[i,&quot;qpos&quot;] if((qpos!=1)&amp;(qpos==(prevqpos+1+corrector))){ snps&lt;-snps[-i,] snps[prevrowname,&quot;rvar&quot;]&lt;-paste0(snps[prevrowname,&quot;rvar&quot;],rvar) snps[prevrowname,&quot;qvar&quot;]&lt;-paste0(snps[prevrowname,&quot;qvar&quot;],qvar) corrector&lt;-corrector+1 i&lt;-i-1 } else { corrector&lt;-0 prevrowname&lt;-rownames(snps)[i] prevqpos&lt;-qpos } i&lt;-i+1 } # Remerge back allvars2&lt;-rbind(snps,inss,dels) remove&lt;-setdiff(rownames(allvars),rownames(allvars2))#?setdiff nucmer&lt;-nucmer[setdiff(rownames(nucmer),remove),] nucmer[rownames(allvars2),]&lt;-allvars2 setTxtProgressBar(pb,pbi) } This chunk of code has several problems: Subsetting mutation records of each sample means exhaustive search, which will scan all rows in each for-loop. When it comes to solve hundreds of thousands rows, this algorithm can be extremely time-consuming. #This subsets all records of each sample allvars&lt;-nucmer[nucmer$qname==sample,] Each sample can be processed independently. However, the above code does not involve concurrency. To solve these problem, we rewrote the code into java, which supports concurrency easily: /** * first group and sort records by sample name, mutation type (insertion, deletion, snp), qpos, rpos, so java only needs to merge records in order, without tedious subsetting. * * @param ses * @return */ public List&lt;SnpsEntity&gt; mergeQpos(List&lt;SnpsEntity&gt; ses) { ses.sort((o1, o2) -&gt; { if (!StrUtil.equals(o1.getQ_name(), o2.getQ_name())) return StrUtil.compare(o1.getQ_name(), o2.getQ_name(), true); if (o1.getType() != o2.getType()) return Integer.compare(o1.getType().ordinal(), o2.getType().ordinal()); if (o1.getQ_pos() != o1.getQ_pos()) return Integer.compare(o1.getQ_pos(), o2.getQ_pos()); return Integer.compare(o1.getR_pos(), o2.getR_pos()); }); List&lt;SnpsEntity&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0, j; i &lt; ses.size(); i = j) { SnpsEntity se = ses.get(i); boolean dbg = false; // dbg = se.getR_pos() == 28280 &amp;&amp; StrUtil.equals(se.getQ_name(), // &quot;hCoV-19/Germany/un-RKI-I-112884/2021|EPI_ISL_1977817|2021-04-23&quot;); if (dbg) System.out.println(se); for (j = i + 1; j &lt; ses.size() &amp;&amp; ses.get(j - 1).canMerge(ses.get(j)); j++) { var sj = ses.get(j); if (dbg) System.out.println(sj); if (se.getType() == SnpsType.INS) se.setQ_var(se.getQ_var() + sj.getQ_var()); else if (se.getType() == SnpsType.DEL) se.setR_var(se.getR_var() + sj.getR_var()); else { se.setR_var(se.getR_var() + sj.getR_var()); se.setQ_var(se.getQ_var() + sj.getQ_var()); } } ans.add(se); } ans.sort((o1, o2) -&gt; { if (!StrUtil.equals(o1.getQ_name(), o2.getQ_name())) return StrUtil.compare(o1.getQ_name(), o2.getQ_name(), true); return Integer.compare(o1.getR_pos(), o2.getR_pos()); }); return ans; } } In java code, it ordered records first and traversed each record once (without subset function), saving a lot time when dealing with large dataset. 4.3.2 Annotate records The annotation process in R: ### Provide effect of each SNP and indel ---- #header&lt;-c(&quot;sample&quot;,&quot;refpos&quot;,&quot;refvar&quot;,&quot;qvar&quot;,&quot;qlength&quot;,&quot;qpos&quot;,&quot;protein&quot;,&quot;variant&quot;,&quot;varclass&quot;,&quot;annotation&quot;) header&lt;-c(&quot;sample&quot;,&quot;refpos&quot;,&quot;refvar&quot;,&quot;qvar&quot;,&quot;qpos&quot;,&quot;qlength&quot;,&quot;protein&quot;,&quot;variant&quot;,&quot;varclass&quot;,&quot;annotation&quot;) results&lt;-matrix(NA,ncol=length(header),nrow=0) colnames(results)&lt;-header samples&lt;-unique(nucmer$qname) pb&lt;-txtProgressBar(0,length(samples),style=3) for (pbi in 1:length(samples)){ # This will update the nucmer object sample&lt;-samples[pbi] allvars&lt;-nucmer[nucmer$qname==sample,] # Check changes in query protein sequence according to variants for(i in 1:nrow(allvars)){ # Assuming they are sorted numerically nucline&lt;-allvars[i,] rpos&lt;-nucline[1,&quot;rpos&quot;] rvar&lt;-nucline[1,&quot;rvar&quot;] qvar&lt;-nucline[1,&quot;qvar&quot;] qpos&lt;-nucline[1,&quot;qpos&quot;] qlength&lt;-nucline[1,&quot;qlength&quot;] # Match over GFF3 annotation for each var in a sample: match the var with the GFF3 a&lt;-rpos-gff3[,4] b&lt;-rpos-gff3[,5] signs&lt;-sign(a)*sign(b) w&lt;-which(signs==-1)#if signs == -1 then rpos in GFF anno # Outside genes scenarios if(length(w)==0){ if(rpos&lt;gff3[1,4]){ #rpos in the upstream of all gene protein&lt;-&quot;5&#39;UTR&quot;;output&lt;-c(rpos,&quot;extragenic&quot;) } else if(rpos&gt;gff3[nrow(gff3),5]){ #?rpos in the downstream of all gene rpos&gt;gff3[nrow(gff3),5] protein&lt;-&quot;3&#39;UTR&quot;;output&lt;-c(rpos,&quot;extragenic&quot;) } else { protein&lt;-&quot;intergenic&quot;;output&lt;-c(rpos,&quot;extragenic&quot;) } } else{ # Inside genes scenario start&lt;-gff3[w,4] end&lt;-gff3[w,5] protein&lt;-gff3[w,9] refdnaseq&lt;-DNAString(paste0(refseq[start:end],collapse=&quot;&quot;)) refpepseq&lt;-Biostrings::translate(refdnaseq) #obtain protein seq refpepseq&lt;-strsplit(as.character(refpepseq),&quot;&quot;)[[1]] if(qvar==&quot;.&quot;){ # Deletion scenario if((nchar(rvar)%%3)!=0){ # Deletion frameshift scenario mutpos&lt;-round((rpos-start+1)/3) output&lt;-c(paste0(refpepseq[mutpos],mutpos),&quot;deletion_frameshift&quot;) } else { # In-frame deletion varseq&lt;-refseq varseq&lt;-varseq[-(rpos:(rpos+nchar(rvar)-1))] varseq&lt;-varseq[start:(end-nchar(rvar))] vardnaseq&lt;-DNAString(paste0(varseq,collapse=&quot;&quot;)) varpepseq&lt;-Biostrings::translate(vardnaseq) varpepseq&lt;-strsplit(as.character(varpepseq),&quot;&quot;)[[1]] for(j in 1:length(refpepseq)){ refj&lt;-refpepseq[j]# varj&lt;-varpepseq[j] #fix if(is.na(refj) | is.na(varj)){ output&lt;-c(paste0(refj,j),&quot;deletion&quot;) break() } if(refj!=varj){ if(varj==&quot;*&quot;){ output&lt;-c(paste0(refj,j),&quot;deletion_stop&quot;) } else { output&lt;-c(paste0(refj,j),&quot;deletion&quot;) } break() } } } } else if(rvar==&quot;.&quot;){ # Insertion scenario if((nchar(qvar)%%3)!=0){ # Insertion frameshift scenario mutpos&lt;-round((rpos-start+1)/3) output&lt;-c(paste0(refpepseq[mutpos],mutpos),&quot;insertion_frameshift&quot;) } else { # In-frame insertion varseq&lt;-c(refseq[1:rpos],strsplit(qvar,&quot;&quot;)[[1]],refseq[(rpos+1):length(refseq)]) varseq&lt;-varseq[start:(end+nchar(qvar))] vardnaseq&lt;-DNAString(paste0(varseq,collapse=&quot;&quot;)) varpepseq&lt;-Biostrings::translate(vardnaseq) varpepseq&lt;-strsplit(as.character(varpepseq),&quot;&quot;)[[1]] for(j in 1:length(refpepseq)){ refj&lt;-refpepseq[j] varj&lt;-varpepseq[j] # fix if(is.na(refj) | is.na(varj)){ output&lt;-c(paste0(refj,j),&quot;insertion&quot;) break() } if(refj!=varj){ nr_aa_inserted&lt;-nchar(qvar)/3 multivarj&lt;-varpepseq[j:(j+nr_aa_inserted-1)] if(any(multivarj==&quot;*&quot;)){ multivarj&lt;-paste0(multivarj,collapse=&quot;&quot;) output&lt;-c(paste0(multivarj,j),&quot;insertion_stop&quot;) } else{ multivarj&lt;-paste0(multivarj,collapse=&quot;&quot;) output&lt;-c(paste0(multivarj,j),&quot;insertion&quot;) } break() } } } } else { # SNP scenario if(nchar(qvar)==1){ # ?Single nucleotide scenario varseq&lt;-refseq varseq[rpos]&lt;-qvar varseq&lt;-varseq[start:end] vardnaseq&lt;-DNAString(paste0(varseq,collapse=&quot;&quot;)) varpepseq&lt;-Biostrings::translate(vardnaseq) varpepseq&lt;-strsplit(as.character(varpepseq),&quot;&quot;)[[1]] mutpos&lt;-which(varpepseq!=refpepseq) #split if(length(mutpos)==0){ # Silent SNP scenario mutpos&lt;-round((rpos-start+1)/3) refaa&lt;-refpepseq[mutpos] varaa&lt;-varpepseq[mutpos] output&lt;-c(paste0(refaa,mutpos,varaa),&quot;SNP_silent&quot;) } else { # Changed aa scenario refaa&lt;-refpepseq[mutpos] varaa&lt;-varpepseq[mutpos] if(varaa==&quot;*&quot;){ output&lt;-c(paste0(refaa,mutpos,varaa),&quot;SNP_stop&quot;) } else { output&lt;-c(paste0(refaa,mutpos,varaa),&quot;SNP&quot;) } } } else { # Multiple neighboring nucleotides varlength&lt;-nchar(qvar) varseq&lt;-refseq varseq[rpos:(rpos+varlength-1)]&lt;-strsplit(qvar,&quot;&quot;)[[1]] varseq&lt;-varseq[start:end] vardnaseq&lt;-DNAString(paste0(varseq,collapse=&quot;&quot;)) varpepseq&lt;-Biostrings::translate(vardnaseq) varpepseq&lt;-strsplit(as.character(varpepseq),&quot;&quot;)[[1]] mutpos&lt;-which(varpepseq!=refpepseq) if(length(mutpos)==0){ # Silent SNP scenario mutpos&lt;-round((rpos-start+1)/3) refaa&lt;-refpepseq[mutpos] varaa&lt;-varpepseq[mutpos] output&lt;-c(paste0(refaa,mutpos,varaa),&quot;SNP_silent&quot;) } else { # Changed aa scenario refaa&lt;-paste0(refpepseq[mutpos],collapse=&quot;&quot;) varaa&lt;-paste0(varpepseq[mutpos],collapse=&quot;&quot;) if(any(varaa==&quot;*&quot;)){ output&lt;-c(paste0(refaa,mutpos[1],varaa),&quot;SNP_stop&quot;) } else { output&lt;-c(paste0(refaa,mutpos[1],varaa),&quot;SNP&quot;) } } } } } results&lt;-rbind(results,c(sample,rpos,rvar,qvar,qpos,qlength,protein,output,annot[protein])) } setTxtProgressBar(pb,pbi) } I used GFF3 table to search for gene region for each record. To avoid traversing GFF3 each time, we rewrote the traversing part into static index (hash table), in which 1 ~ 30000 genomic coordinates are mapped to gene region and protein group. This index only took up several hundred kilobyte. In java, stream() mode can be switched to parallel mode to achieve parallel computing: if (mutpos.isEmpty()) { var mp = Math.round((rpos - ge.getStPos() + 1) / 3.0f); mutpos.add(mp); varaa = varPepSeq.getCompoundAt(mp).toString(); sae.setVarclass(&quot;SNP_silent&quot;); } else { varaa = StrUtil.join(StrUtil.EMPTY, mutpos.stream().map(varPepSeq::getCompoundAt).collect(Collectors.toList())); if (varaa.contains(&quot;*&quot;)) sae.setVarclass(&quot;SNP_STOP&quot;); else sae.setVarclass(&quot;SNP&quot;); } sae.setVariant( StrUtil.join(StrUtil.EMPTY, mutpos.stream().map(refPepSeq::getCompoundAt).collect(Collectors.toList())) + mutpos.get(0) + varaa); } /** * also use hash table (codon table) to map mutated trinucleotide to amino acid. * @return */ 4.4 Some tricks One notable thing is that the division operation can be different between R and java when rewriting code. In R: 8/3 # [1] 2.666667 In java: 8/3 # 2 In some cases, this can lead to serious problems. Instead of 8/3, you should write: 8/3.0. References "]]
